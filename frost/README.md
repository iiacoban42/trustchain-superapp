
# FROST app

The **FROST** app aims to create a fully decentralized DAO which enables joint ownership of Bitcoin funds which can be spent by participating in a k-out-of-n Schnorr signature.

## Overview
The app integrates the **Flexible Round-Optimized Schnorr Threshold (FROST)** Signatures algorithm presented [in this paper](https://eprint.iacr.org/2020/852.pdf) with the IPv8 overlay. The **FROST** algorithm is implemented in the following [library](https://github.com/OrestisKan/secp256k1-zkp-jni): which is compiled as an `.so` file and accessed from the app using JNI bindings. Currently, there are JNI calls for generating public and private key pairs, computing and distributing key shares used in the sign rounds, as well as signature verifications. Furthermore, the peers can exchange public keys and key shares with the IPv8 overlay.

The FROST algorithm primitive cryptographic operations are implemented in the `secp256k1` library in native code, and exposed to the `BitcoinJ` library [through JNI](https://github.com/OrestisKan/bitcoinj-frost/blob/91b74783de9bd1e1f5bb69749197987d79b9bb7d/core/src/main/java/org/bitcoin/NativeSecp256k1.java#L586). This extension of `BitcoinJ` allows for setting up public/private keys for `N` participants in **two rounds of communication**, signing a message by a subset of size `T` out of them in two rounds of communication, and verifying a `T-out-of-N` signature with a unique aggregated public key.

## Functionality
 
The **FROST** android app serves to demonstrate the potential use of the **FROST** algorithm on android devices. Through a series of button clicks, the user can initiate the key-generation protocol and perform **the first round of communication** needed to set up the scheme. The user can see on their screen the intermediate results of public/private variables broadcast to/from their peers. As the end goal is to allow for joint ownership of Bitcoin for communities in the Music DAO, for the purpose of decentralized, democratic control over resources, the FROST app requires plenty additional work to achieve its end goal. Having a user **manually perform** the algorithmic steps of key distribution is thus only interesting for **debugging** and **demonstrative purposes**.
 
<img src="src/img/frost_gif.gif" height="400px">
 
- **JOIN FROST**: initiates the process by creating a signer for this peer (peerA). A signer is an object that, among other things, contains a public key. This signer is broadcast to all the peers in the **FrostCommunity**. When another peer (peerB) receives the signer from peerA, it creates its own signer and broadcasts it to everyone in the FrostCommunity if it hasn't already created a signer before.
- **REFRESH SIGNERS**: the peer's own signer and the signers received from other peers are saved in a local variable and their IPs and public keys are also saved in a file in memory so that they can easily be displayed on the screen when this button is pressed.
- **SEND SHARES**: the next step is to generate shares of the private key. These shares must be generated by all peers by pressing the SEND SHARES button, which also broadcasts them to peers whose signers are known.
- **REFRESH SHARES**: just like the signers, the shares are saved in a local variable and the IPs of the peers who sent those shares are saved in a file in the memory to be displayed on the screen.

The buttons implemented follow the structure of the `testKeyCreationAndAggregation` method which can be found [here](https://github.com/OrestisKan/bitcoinj-frost/blob/91b74783de9bd1e1f5bb69749197987d79b9bb7d/core/src/test/java/org/bitcoinj/core/ECKeyTest.java#L550). This test checks that all the relevant JNI calls are executed correctly in a localized environment (i.e. on the same device). IPv8 is used to move this execution into a distributed environment, but the **current progress stops** roughly at [line 283](https://github.com/iiacoban42/trustchain-superapp/blob/b084dfbe5ff72709c60aac968f6d47e071cee571/frost/src/main/java/nl/tudelft/trustchain/frost/FrostCommunity.kt#L283), where `receiveFrost` would be called. We suspect that, since the JNI calls themselves work locally, there is either an issue with the input provided or with the variables saved in memory (which could be caused by the serialization/deserialization of data needed to send it through IPv8, for which the code is in `src/main/java/nl/tudelft/trustchain/frost/FrostSignerPacket.kt`)

## Limitations 

The 4 buttons must be pressed in the order given above (**JOIN FROST** can be pressed by only 1 peer, but more peers pressing it **should not cause issues**, while **SEND SHARES** will recreate the shares and send them again, which **might not be ideal**, so it is **advised** to only press once per peer to ensure consistency). A future implementation might use acks to verify when steps are done so that only one of the peers would have to press the button once and the others would only be notified to vote to contribute to the signature if they wanted to.

The .so file is compiled for both **ARM** and **x86** architectures. However, it was tested only on ARM using real Android Devices, it did not work on the Emulators using **x86**.

The next **development step** to take for the **FROST** app are to **automate the key generation mechanism**, while only exposing to the user functionality such as initiating the creation of a community, joining one, and accepting users to a community. Afterwards, a user of a community should be able to initiate and vote on proposals, which would internally correspond to initiating the signing procedure, requesting partial signatures from peers in the community, and aggregating the signatures to be able to spend the money on the proposal.

